<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jtpan World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Tuesday, 22. August 2017 11:02AM  #Item 3: Understand decltype #条目３： 理解decltype ##术语&amp;amp;概念  ###decltype对于一个给定的名称或表达式，decltype会告诉你这个名称或表达式的类型。  ##快速笔记  大多数情况下decltype会准确的给出你所预期的类型 在C++11中，decltype可能的主">
<meta property="og:type" content="article">
<meta property="og:title" content="Jtpan World">
<meta property="og:url" content="http://justuspan.github.io/cj74b3esv0000hnoi1gyg57md/index.html">
<meta property="og:site_name" content="Jtpan World">
<meta property="og:description" content="Tuesday, 22. August 2017 11:02AM  #Item 3: Understand decltype #条目３： 理解decltype ##术语&amp;amp;概念  ###decltype对于一个给定的名称或表达式，decltype会告诉你这个名称或表达式的类型。  ##快速笔记  大多数情况下decltype会准确的给出你所预期的类型 在C++11中，decltype可能的主">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-09-03T05:38:06.636Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jtpan World">
<meta name="twitter:description" content="Tuesday, 22. August 2017 11:02AM  #Item 3: Understand decltype #条目３： 理解decltype ##术语&amp;amp;概念  ###decltype对于一个给定的名称或表达式，decltype会告诉你这个名称或表达式的类型。  ##快速笔记  大多数情况下decltype会准确的给出你所预期的类型 在C++11中，decltype可能的主">
  
    <link rel="alternate" href="/atom.xml" title="Jtpan World" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jtpan World</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://justuspan.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-EMC++I03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cj74b3esv0000hnoi1gyg57md/" class="article-date">
  <time datetime="2017-09-03T05:38:06.636Z" itemprop="datePublished">2017-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tuesday, 22. August 2017 11:02AM </p>
<p>#Item 3: Understand decltype</p>
<p>#条目３： 理解decltype</p>
<p>##术语&amp;概念</p>
<ul>
<li>###<strong>decltype</strong><br>对于一个给定的名称或表达式，decltype会告诉你这个名称或表达式的类型。</li>
</ul>
<p>##快速笔记</p>
<ol>
<li>大多数情况下decltype会准确的给出你所预期的类型</li>
<li>在C++11中，decltype可能的主要用途就是在某种情况下用来声明函数模板的返回值，这里特指在这个函数的返回值类型取决于它的形参类型的情况下。<ul>
<li>trailing return type 语法</li>
<li>C++14 的前置decltype语法</li>
<li>修订一：universal reference</li>
<li>修订二：perfect forward</li>
</ul>
</li>
<li>decltype制造“惊喜”的情况：当对名称以外的更复杂的东西使用decltype时，结果可能有点意外。比如decltype(x)和decltype((x))。</li>
</ol>
<p>##例子<br>==Example 1==<br>这里的例子中decltype不出所料地，鹦鹉学舌般准确地回答了所给出的名字或是表达式的类型，没有制造意外。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">count int i = 0; // decltype(i) is const int</div><div class="line"></div><div class="line">bool f(const Widget&amp; w); 	// decltype(w) is const Widget&amp;</div><div class="line">				// decltype(f) is bool(const Widget&amp;)</div><div class="line"></div><div class="line">struct Point &#123;</div><div class="line">  int x, y;		//decltype(Point::x) is int</div><div class="line">&#125;; 			//decltype(Point::y) is int</div><div class="line"></div><div class="line">Widget w;		//decltype(w) is Widget</div><div class="line"></div><div class="line">if (f(w)) ...		//decltype(f(w)) is bool</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">class vector &#123;</div><div class="line">public:</div><div class="line">  ...</div><div class="line">  T&amp; operator[](std::size_t index);</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">vector&lt;int&gt; v;		//decltype(v) is vector&lt;int&gt;</div><div class="line">...</div><div class="line">if (v[0] == 0) ...	//decltype(v[0]) is int&amp;</div></pre></td></tr></table></figure></p>
<p>==Example 2==<br>下面来看decltype如何运用于声明函数模板。需要注意的是这种实现可以工作但是还能做一些<strong>改进</strong>，此处先按下不表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt;	// works, but</div><div class="line">auto authAndAccess(Container&amp; c, Index i) 	// requires</div><div class="line">-&gt; decltype(c[i])				// refinement</div><div class="line">&#123;</div><div class="line">  authenticateUser();</div><div class="line">  return c[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里auto类型指示符（type-specifier）并没有做什么与类型推断相关的事情。它其实指明了C++11的<em>后置返回类型</em>（trailing return type）语法在此处被使用。<br>这种语法的好处是你可以使用形参列表里的参数来表达自己让编译器推断的类型，以往的前置返回值无法获知形参，因为那个时候形参们尚未被声明。<br>此种情况中在C++11 中必须要写上这种特殊语法，但是在C++14中，这样的后置语法可以忽略，编译器会自动去推断return 之后的表达式的类型作为返回类型。例子如下，同时要注意如下的例子其实并不正确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">templates &lt;typename Container, typename Index&gt;	//C++14</div><div class="line">auto authAndAccess(Container&amp; c, Index i)	//not quite </div><div class="line">&#123;						//correct</div><div class="line">  authenticateUser();</div><div class="line">  return c[i];			//return type deduced from c[i]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>条目2向我们解释了对于函数的auto返回类型推断实际上使用了模板类型推断。在这个例子里等价的模板推断如下(仅笔者理解，待考)，下述例子中T的推断结果便是上面这个片段里的返回类型推断结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">void fun_for_authAndAccess(T param);</div><div class="line"></div><div class="line">std::deque&lt;int&gt; d;</div><div class="line">...</div><div class="line">func_for_authAndAccess(d[5]);	//func_for_authAndAccess(expr)</div></pre></td></tr></table></figure></p>
<p>如果是这样的形式，我们发现其对应条目1中所介绍的模板类型推断的第三种情况。即</p>
<p><strong>Case 3: 当paramType既不是指针也不是引用时</strong>，</p>
<ul>
<li>如果实参expr的类型是reference，忽略reference的部分。</li>
<li>如果忽略reference之后还有const，一并忽略。volatile也忽略。最后将expr与paramType匹配。</li>
</ul>
<p>根据上述诀窍我们来看看这个例子中T的推断结果： d[5]的类型是int&amp;, 忽略掉该忽略的部分以后还剩下int，paramType的类型是T，因此T的类型被推断为int。这种结果在我们这里例子中是会带来问题的。int作为一个函数的返回类型是一个右值(rvalue)。也意味着以下代码编译无法通过，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">std::deque&lt;int&gt; d;</div><div class="line">...</div><div class="line">authAndAccess(d,5) = 10; 	// authenticate user, return d[5]</div><div class="line">				// then assgin 10 to it;</div><div class="line">				//this won&apos;t compile!</div></pre></td></tr></table></figure></p>
<p>为了使authAndAccess如我们预想的那样工作，这里还需要对它的返回类型作decltype类型推断。像这样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt;	// C++14; works,</div><div class="line">decltype(auto)					// but still</div><div class="line">authAndAccess(Container&amp; c, Index i)		// requires</div><div class="line">&#123;						// refinement</div><div class="line">  authenticateUser();</div><div class="line">  return c[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在authAndAccess就真的会和c[i]返回一样的东西。<br>decltype(auto)这种用法不局限于函数返回类型也能用于变量声明。比如像这样应用于初始化表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Widget w;</div><div class="line"></div><div class="line">const Widget&amp; cw = w;</div><div class="line"></div><div class="line">auto myWidget1 = cw;	// auto type deduction</div><div class="line">			// myWidget1&apos;s type is Widget</div><div class="line">			</div><div class="line">decltype(auto) myWidget2 = cw;	// decltype type deduction;</div><div class="line">				// myWidget2&apos;s type is </div><div class="line">				// const Widget&amp;</div></pre></td></tr></table></figure></p>
<p>接下来我们讲讲之前提到的这个函数模板的<strong>改进</strong>问题。</p>
<p>####修订一：universal reference<br>来观察C++14版的authAndAccess声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt;</div><div class="line">decltype(auto) authAndAccess(Container&amp; c, Index i);</div></pre></td></tr></table></figure></p>
<p>我们可以发现只有容器的非const左值引用(lvalue-reference-to-non-const)可以被传为第一参数。<br>右值(rvalue)并不能作为这里的参数。<br>不可否认的是，给authAndAccess传递右值容器是一种极端情况。因为右值容器是一个临时对象，通常会在包含authAndAccess调用的语句结束时就被销毁，同时意味着对这个容器内某个元素的引用也会被悬空。<br>但是如果说用户仅仅是想利用到这个临时容器的某个元素的拷贝也是说得通的。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">std::deque&lt;std::string&gt; makeStringDeque();	// factory function</div><div class="line"></div><div class="line">// make copy of 5th element of deque returned</div><div class="line">// from makeStringDeque</div><div class="line">auto s = authAndAccess(makeStringDeque(),5);</div></pre></td></tr></table></figure></p>
<p>为了支持这样的使用方式意味要改进authAndAccess的声明使得可以同时处理lvalue和rvalue。Overloading是一个选择，但是我们需要维护两个函数，一个以lvalue reference为形参，另一个以rvalue reference为形参。<br>避免这个问题的方法是：使用universal reference。我们可以作如下的函数模板声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt;  //c is now  </div><div class="line">decltype(auto) authAndAccess(Container&amp;&amp; c, Index i);	  // universal reference</div></pre></td></tr></table></figure></p>
<p>注意到这里对Index这个类型未知的对象使用了按值传参(pass-by-value). 通常按值传参存在三个风险：</p>
<ul>
<li>不必要的对象拷贝导致性能(performance)上的忧虑</li>
<li>存在发生对象剪切（object slicing）（见Item 41）的风险。</li>
<li>来自同侪的嘲讽(derision)<br>但是就这个具体问题（一个容器的索引）而言，沿用标准库的做法(eg. operator[] for std::string, std::vector, std::deque)看起来是合理的。所以我们这里对索引坚持使用了pass-by-value.</li>
</ul>
<p>####修订二： perfect forward<br>然而，根据Item 25给我们的告诫：为universal reference使用std::forward<br>我们仍需做出以下改进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt;  // final C++14 version</div><div class="line">decltype(auto)	</div><div class="line">authAndAccess(Container&amp;&amp; c, Index i)</div><div class="line">&#123;</div><div class="line">  authenticateUser();</div><div class="line">  return std::forward&lt;Container&gt;(c)[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有一个能支持C++14的编译器，那么就采用如下等价写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Container, typename Index&gt; // final C++11 version</div><div class="line">auto</div><div class="line">authAndAccess(Container&amp;&amp; c, Index i)</div><div class="line">-&gt; decltype(std::forward&lt;Container&gt;(c)[i])</div><div class="line">&#123;</div><div class="line">  authenticateUser();</div><div class="line">  return std::forward&lt;Container&gt;(c)[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>==Example 3==<br>decltype<strong>几乎</strong>总是能产生你所预期的类型,少数情况下会制造“惊喜”。说实话，你不太可能碰到这些规律的例外情况，除非你是个负有重大责任(heavy-duty)的库实现者。<br>要完全理解掌握decltype的行为，你不得不使自己熟悉极少的特例。大多数的特例过于晦涩，我们按下不表。但是我们可以来看一个例子来更深入了解一下decltype和它的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int x = 0;</div></pre></td></tr></table></figure></p>
<p><code>x</code>是一个变量的名称，所以<code>decltype(x)</code>是int, 但是如果将<code>x</code>用括号包裹起来变成<code>(x)</code>,产生了一个比单纯名称要复杂一点表达式时，情况有所不同。作为一个名称，<code>x</code>是一个左值（lvalue），而且C++也将表达式<code>(x)</code>定义为左值。因此<code>decltype((x))</code>的结果是<code>int&amp;</code> 。<br>在C++11中， 这个现象只是一个令人好奇的小玩意。但是在结合和C++14的<code>decltype(auto)</code>的语法之后，这意味着你对return语句进行一个看似无关紧要的改动也能影响到函数返回值的类型推断结果。见下例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">decltype(auto) f1()</div><div class="line">&#123;</div><div class="line">  int x = 0;</div><div class="line">  ...</div><div class="line">  return x;	//decltype(x) is int, so f1 returns int</div><div class="line">&#125;</div><div class="line"></div><div class="line">decltype(auto) f2()</div><div class="line">&#123;</div><div class="line">  int x = 0;</div><div class="line">  ...</div><div class="line">  return (x);	//decltype((x)) is int&amp;, so f2 returns int&amp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要注意到这不仅是f2的返回类型和f1不同的问题。f2返回了一个局部变量的引用！像这样的代码将你丢到了名为未定义行为(undefined behavior)的特快列车上， 一辆你肯定不想上的列车。</p>
<p>重要的告诫就是，当你使用decltype(auto)的时候要非常当心。</p>
<p>##谨记要点</p>
<ul>
<li>decltype<strong>几乎</strong>总是不加改动地产生一个变量或是表达式的类型。</li>
<li>对类型为T的，除了名称(name)以外的其他左值表达式(lvalue expression)，decltype总是报告一个<code>T&amp;</code>类型。</li>
<li>C++14支持<code>decltype(auto)</code>语法。这就像auto一样，从初始化器推断一个类型，只不过它执行的是decltype的推断规则。（jtpan：去推断 declared type，而不是auto的规则：函数模板返回类型推断的规则）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://justuspan.github.io/cj74b3esv0000hnoi1gyg57md/" data-id="cj74b3esv0000hnoi1gyg57md" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/cj74b3esz0002hnoilcxgh95z/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/cj74b3esv0000hnoi1gyg57md/">(no title)</a>
          </li>
        
          <li>
            <a href="/cj74b3esz0002hnoilcxgh95z/">(no title)</a>
          </li>
        
          <li>
            <a href="/cj74b3et00003hnoi0t7d1rhy/">第一篇测试文</a>
          </li>
        
          <li>
            <a href="/cj74b3esy0001hnoiwdfum459/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Jtpan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>